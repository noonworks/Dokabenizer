<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Dokabenizer</title>
</head>
<body>
<h1>Dokabenizer</h1>
<p><a href="http://newdokabenfont.blog.jp/archives/12570669.html">新ドカベンフォント（NewDokabenFont.otf）</a>をインストールしておくとそれっぽくなります。</p>
<table>
<tr><th>文字</th><td><input type="text" id="in_text" value="ドカベン" /></td></tr>
<tr><th>FPS（1秒あたりのコマ数）</th><td><input type="text" id="in_fps" value="8" /></td></tr>
<tr><th>動く時間（ミリ秒）</th><td><input type="text" id="in_msec" value="1500" /></td></tr>
<tr><th>前の間（ミリ秒）</th><td><input type="text" id="in_before" value="800" /></td></tr>
<tr><th>後の間（ミリ秒）</th><td><input type="text" id="in_after" value="1700" /></td></tr>
<tr><td colspan="2" style="text-align:center"><button id="dokabenize">ドカベン</button></td></tr>
<tr><td colspan="2" style="text-align:center">
<button id="savegif">GIF ホゾン</button>
<button id="savegif_ie">IE ハ コッチ</button>
</td></tr>
</table>
<canvas id="dokaben_canvas" width="10" height="10"></canvas>
<br />
<p id="save_ie_note" style="display:none">↓下の画像は保存できます</p>
<script src="gif.js"></script>
<script>
(function(){
  // Tile
  var DokabenTile = (function() {
    function DokabenTile(bgcolor) {
      this._tmp_canvas = document.createElement('canvas');
      this._tmp_context = this._tmp_canvas.getContext("2d");
      this.canvas = document.createElement('canvas');
      this._resetInfo();
      this.fill = DokabenTile.DEFAULT_FILL;
      this.stroke = DokabenTile.DEFAULT_STROKE;
      this.bgcolor = bgcolor;
    }
    DokabenTile.prototype.drawText = function(text) {
      // resize canvas
      this._tmp_canvas.height = DokabenTile.DEFAULT_FONT_SIZE * 2;
      this._setFont();
      var w = this._tmp_context.measureText(text).width + DokabenTile.MARGIN * 2;
      this._tmp_canvas.width = w;
      // draw text
      this._tmp_context = this._tmp_canvas.getContext("2d");
      this._tmp_context.clearRect(0, 0, this._tmp_canvas.width, this._tmp_canvas.height);
      this._setFont();
      this._tmp_context.fillText(text, DokabenTile.MARGIN, DokabenTile.MARGIN);
      this._tmp_context.strokeText(text, DokabenTile.MARGIN, DokabenTile.MARGIN);
      // get real size
      this._getPosition();
      this.width = this.right - this.left + 1;
      this.height = this.bottom - this.top + 1;
      // copy clopped text
      var w = this.width;
      var h = this.height;
      if (w % 2 != 0) w++;
      if (h % 2 != 0) h++;
      this.canvas.width = w;
      this.canvas.height = h;
      var ctx = this.canvas.getContext("2d");
      if (typeof(this.bgcolor) != 'undefined') {
        ctx.fillStyle = this.bgcolor;
        ctx.fillRect(0, 0, this.width, this.height);
      }
      ctx.drawImage(this._tmp_canvas, this.left, this.top, this.width, this.height, 0, 0, this.width, this.height);
    };
    DokabenTile.prototype._resetInfo = function() {
      var arr = ['top', 'left', 'bottom', 'right', 'width', 'height'];
      for (var i = 0; i < arr.length; i++)
        this[arr[i]] = -1;
    };
    DokabenTile.prototype._setFont = function() {
      this._tmp_context.fillStyle = this.fill;
      this._tmp_context.strokeStyle = this.stroke;
      this._tmp_context.lineWidth = DokabenTile.STROKE_WIDTH;
      this._tmp_context.font = "" + DokabenTile.DEFAULT_FONT_SIZE + "px " + DokabenTile.FONTS.join(',');
      this._tmp_context.textBaseline = 'top';
    };
    DokabenTile.prototype._getPosition = function() {
      this._resetInfo();
      var pixels = this._tmp_context.getImageData(0, 0, this._tmp_canvas.width, this._tmp_canvas.height);
      var data = pixels.data;
      // get top and bottom
      for (var i = 0; i < (data.length / 4); i++) {
        var b_i = (data.length / 4) - i;
        if (this.top < 0 && data[i * 4 + 3] > 0)
          this.top = Math.floor(i / this._tmp_canvas.width);
        if (this.bottom < 0 && data[b_i * 4 + 3] > 0)
          this.bottom = Math.floor(b_i / this._tmp_canvas.width);
        if (this.top >= 0 && this.bottom >= 0) break;
      }
      // get left and right
      for (var l_x = 0; l_x < this._tmp_canvas.width; l_x++) {
        var r_x = this._tmp_canvas.width - l_x - 1;
        for (var l_y = 0; l_y < this._tmp_canvas.height; l_y++) {
          var r_y = this._tmp_canvas.height - l_y - 1;
          var l_index = l_y * this._tmp_canvas.width + l_x;
          var r_index = r_y * this._tmp_canvas.width + r_x;
          if (this.left < 0 && data[l_index * 4 + 3] > 0)
            this.left = l_x;
          if (this.right < 0 && data[r_index * 4 + 3] > 0)
            this.right = r_x;
          if (this.left >= 0 && this.right >= 0) break;
        }
        if (this.left >= 0 && this.right >= 0) break;
      }
    };
    return DokabenTile;
  })();
  DokabenTile.MARGIN = 8;
  DokabenTile.STROKE_WIDTH = 4;
  DokabenTile.DEFAULT_FONT_SIZE = 120;
  DokabenTile.DEFAULT_FILL = 'rgb(200,40,40)';
  DokabenTile.DEFAULT_STROKE = 'rgb(100,10,30)';
  DokabenTile.FONTS = ["'NewDokabenFont'"];
  
  // Ticker
  var DokabenTicker = (function() {
    function DokabenTicker(fps, msec, wait_before, wait_after) {
      this.fps = fps || DokabenTicker.DEFAULT_FPS;
      this.msec = msec || DokabenTicker.DEFAULT_MSEC;
      this.wait_before = wait_before || DokabenTicker.DEFAULT_BEFORE;
      this.wait_after = wait_after || DokabenTicker.DEFAULT_AFTER;
      this.reset();
      this.paused = true;
    }
    DokabenTicker.prototype.start = function() {
      this.reset();
      this.restart();
    };
    DokabenTicker.prototype.reset = function() {
      this._paused_ms = 0;
    };
    DokabenTicker.prototype.restart = function() {
      this.paused = false;
      this._seed = (new Date()).getTime();
    };
    DokabenTicker.prototype.pause = function() {
      this._paused_ms = this._tickMs();
      this.paused = true;
    };
    DokabenTicker.prototype._tickMs = function() {
      if (this.paused) return this._paused_ms;
      return (new Date()).getTime() - this._seed + this._paused_ms;
    };
    DokabenTicker.prototype.getRotation = function() {
      var ms = this._tickMs(this.fps) % (this.msec + this.wait_before + this.wait_after);
      if (ms < this.wait_before) return Math.PI * DokabenTicker.MIN_ROTATE;
      if (ms >= this.wait_before + this.msec) return Math.PI * DokabenTicker.MAX_ROTATE;
      var f = Math.floor((ms - this.wait_before) / (1000 / this.fps));
      var max_f = Math.floor(this.fps * this.msec / 1000);
      return Math.PI * (DokabenTicker.ROTATE_RANGE / max_f * f + DokabenTicker.MIN_ROTATE);
    };
    return DokabenTicker;
  })();
  DokabenTicker.DEFAULT_FPS = 8;
  DokabenTicker.DEFAULT_MSEC = 1500;
  DokabenTicker.DEFAULT_BEFORE = 800;
  DokabenTicker.DEFAULT_AFTER = 1700;
  DokabenTicker.MIN_ROTATE = -0.5;
  DokabenTicker.MAX_ROTATE = 0;
  DokabenTicker.ROTATE_RANGE = 0.5;
  
  // animation panel
  var DokabenPanel = (function() {
    function DokabenPanel(tile, ticker, bgcolor) {
      var e = document.getElementById(DokabenPanel.ID);
      if (!e) {
        this.canvas = document.createElement('canvas');
        this.canvas.id = DokabenPanel.ID;
        document.body.appendChild(this.canvas);
      } else {
        this.canvas = e;
      }
      this.renderer = new THREE.WebGLRenderer({ alpha: true, preserveDrawingBuffer: true });
      if (typeof(bgcolor) != 'undefined') {
        this.bgcolor = bgcolor;
      }
      this.scene = new THREE.Scene();
      if (!tile) tile = null;
      this.setTile(tile);
      if (!ticker) ticker = new DokabenTicker();
      this.setTicker(ticker);
    }
    DokabenPanel.prototype.setAlpha = function(alpha) {
      if (alpha) {
        this.renderer.alpha = true;
      } else {
        this.renderer.alpha = false;
      }
    };
    // control
    DokabenPanel.prototype.start = function() {
      if (!this.ticker || ! this.ticker.paused) return;
      console.log('start');
      this.ticker.restart();
      this._update();
    };
    DokabenPanel.prototype.pause = function() {
      if (!this.ticker || this.ticker.paused) return;
      console.log('pause');
      this.ticker.pause();
      cancelAnimationFrame(this.animeteID);
    };
    // animation
    DokabenPanel.prototype._update = function() {
      if (!this.ticker) return;
      var me = this;
      this.animeteID = requestAnimationFrame(function(){me._update();});
      this.plane.rotation.x = this.ticker.getRotation();
     // console.log(this.plane.rotation.x);
      this._render();
    };
    DokabenPanel.prototype.renderRotate = function(rotation) {
      this.plane.rotation.x = rotation;
      this._render();
    };
    DokabenPanel.prototype._render = function() {
      this.renderer.render(this.scene, this.camera);
      if (typeof(this.bgcolor) != 'undefined') {
        this.context.fillRect(0, 0, this.width, this.clop_height);
      } else {
        this.context.clearRect(0, 0, this.width, this.clop_height);
      }
      this.context.drawImage(this.renderer.domElement, 0, 0);
    };
    // set ticker
    DokabenPanel.prototype.setTicker = function(ticker) {
      this.pause();
      this.ticker = ticker;
    };
    // set tile
    DokabenPanel.prototype.setTile = function(tile) {
      this._clearScene();
      this.tile = tile;
      this._setSize();
      this._addPlane();
    };
    DokabenPanel.prototype._setSize = function() {
      this.width = this.tile.width + DokabenPanel.DEFAULT_PADDING * 2;
      if (this.width % 10 != 0) this.width += 10 - (this.width % 10);
      this.height = this.tile.height + DokabenPanel.DEFAULT_PADDING * 2;
      if (this.height % 10 != 0) this.height += 10 - (this.height % 10);
      this.clop_height = this.height;
      this.height += this.tile.height;
      this.aspect = this.width / this.height;
      this.tile.aspect = this.tile.width / this.tile.height;
      // h0 = harf of the tile height
      var h0_px = this.tile.height / 2;
      // z0 = camera to near clip = 1
      var z0_px = this.height / 2 / Math.tan(Math.PI * DokabenPanel.FOV / 360);
      // h1 = harf of the plane height = 1 / 2 = z0 / 2
      var h1_px = z0_px / 2;
      // z1 = camera to the plane (calculate with Similarity of triangle)
      var z1_px = z0_px * h1_px / h0_px;
      // pixel to virtual
      this.far = z1_px / z0_px;
      // resize objects
      this.renderer.setSize(this.width, this.height);
      this.camera = new THREE.PerspectiveCamera(DokabenPanel.FOV, this.aspect, 1, 100);
      this.canvas.width = this.width;
      this.canvas.height = this.clop_height;
      this.context = this.canvas.getContext("2d");
      if (typeof(this.bgcolor) != 'undefined') {
        this.context.fillStyle = this.bgcolor;
      }
    };
    DokabenPanel.prototype._addPlane = function() {
      this.geometry = new THREE.PlaneGeometry(this.tile.aspect, 1);
      // move the object up to harf of it (set rotate-axis to the bottom of it)
      this.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
      var tx = new THREE.Texture(this.tile.canvas);
      tx.needsUpdate = true;
      tx.minFilter = THREE.LinearFilter;
      tx.magFilter = THREE.LinearFilter;
      //console.log(tx);
      this.material = new THREE.MeshBasicMaterial({map: tx});
      this.plane = new THREE.Mesh(this.geometry, this.material);
      // lie down the plane
      this.plane.rotation.x = Math.PI * DokabenPanel.MIN_ROTATE;
      // set distance from camera
      this.plane.position.z = -1 * this.far;
      this.scene.add(this.plane);
    };
    DokabenPanel.prototype._clearScene = function() {
      if (this.geometry) this.geometry.dispose();
      if (this.material) this.material.dispose();
      if (this.plane) this.scene.remove(this.plane);
    };
    DokabenPanel.prototype.dispose = function() {
      this.pause();
      this._clearScene();
      document.body.removeChild(this.canvas);
    };
    return DokabenPanel;
  })();
  DokabenPanel.DEFAULT_PADDING = 10;
  DokabenPanel.FOV = 30;
  DokabenPanel.MAX_ROTATE = 0;
  DokabenPanel.MIN_ROTATE = -0.5;
  DokabenPanel.ID = 'dokaben_canvas';
  
  function readInt(id, min, default_val) {
    var str = document.getElementById(id).value;
    var i = parseInt(str, 10);
    if (isNaN(i) || (i < min)) {
      document.getElementById(id).value = default_val;
      return default_val;
    }
    return i;
  }
  
  function loadSetting() {
    return {
      text: document.getElementById('in_text').value,
      fps: readInt('in_fps', 1, DokabenTicker.DEFAULT_FPS),
      msec: readInt('in_msec', 1, DokabenTicker.DEFAULT_MSEC),
      before: readInt('in_before', 0, DokabenTicker.DEFAULT_BEFORE),
      after: readInt('in_after', 0, DokabenTicker.DEFAULT_AFTER)
    };
  }
  
  var DEFAULT_BGCOLOR = "rgb(255, 255, 255)";
  var dokaben_panel = null;
  function preview() {
    if (dokaben_panel) dokaben_panel.dispose();
    var setting = loadSetting();
    var tile = new DokabenTile(DEFAULT_BGCOLOR);
    tile.drawText(setting.text);
    dokaben_panel = new DokabenPanel(tile, null, DEFAULT_BGCOLOR);
    dokaben_panel.ticker.fps = setting.fps;
    dokaben_panel.ticker.msec = setting.msec;
    dokaben_panel.ticker.wait_before = setting.before;
    dokaben_panel.ticker.wait_after = setting.after;
    dokaben_panel.start();
  }
  
  
  var MockTicker = (function() {
    function MockTicker() {
    }
    MockTicker.prototype.getRotation = function() {
      var ms = this._tickMs(this.fps) % (this.msec + this.wait_before + this.wait_after);
      if (ms < this.wait_before) return Math.PI * DokabenTicker.MIN_ROTATE;
      if (ms >= this.wait_before + this.msec) return Math.PI * DokabenTicker.MAX_ROTATE;
      var f = Math.floor((ms - this.wait_before) / (1000 / this.fps));
      var max_f = Math.floor(this.fps * this.msec / 1000);
      return Math.PI * (DokabenTicker.ROTATE_RANGE / max_f * f + DokabenTicker.MIN_ROTATE);
    };
    return MockTicker;
  })();
  
  function save(callback) {
    preview();
    dokaben_panel.pause();
    var setting = loadSetting();
    var max_f = Math.floor(setting.fps * setting.msec / 1000);
    var delay = 1000 / setting.fps;
    if (delay < 1) delay = 1;
    var gif = new GIF({
      workers: 2,
      quality: 10
    });
    dokaben_panel.renderRotate(Math.PI * DokabenTicker.MIN_ROTATE);
    gif.addFrame(dokaben_panel.canvas, {delay: setting.before, copy: true});
    for (var f = 1; f < max_f; f++) {
      dokaben_panel.renderRotate(Math.PI * (DokabenTicker.ROTATE_RANGE / max_f * f + DokabenTicker.MIN_ROTATE));
      gif.addFrame(dokaben_panel.canvas, {delay: delay, copy: true});
      console.log(Math.PI * (DokabenTicker.ROTATE_RANGE / max_f * f + DokabenTicker.MIN_ROTATE));
      console.log(delay);
    }
    dokaben_panel.renderRotate(Math.PI * DokabenTicker.MAX_ROTATE);
    gif.addFrame(dokaben_panel.canvas, {delay: setting.after, copy: true});
    gif.on('finished', callback);
    gif.render();
  }
  
  function save_ie() {
    save(function(blob) {
      dokaben_panel.start();
      var e = document.getElementById('save_img');
      if (!e) {
        var img = document.createElement('img');
        img.id = 'save_img';
        document.body.appendChild(img);
      } else {
        img = e;
      }
      img.src = URL.createObjectURL(blob);
      document.getElementById('save_ie_note').style = "";
    });
  }
  
  function save_hoka() {
    save(function(blob) {
      dokaben_panel.start();
      window.open(URL.createObjectURL(blob));
    });
  }
  
  function initialize() {
    var button = document.getElementById('dokabenize');
    button.addEventListener('click', preview, false);
    var savebutton = document.getElementById('savegif');
    savebutton.addEventListener('click', save_hoka, false);
    var savebutton_ie = document.getElementById('savegif_ie');
    savebutton_ie.addEventListener('click', save_ie, false);
  }
  
  addEventListener("load", initialize, false);
})();
</script>
</body>
</html>
